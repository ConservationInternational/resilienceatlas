name: CodeDeploy - Staging

on:
  push:
    branches:
      - staging
  workflow_dispatch:
    inputs:
      sync_database:
        description: 'Sync production database to staging'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  AWS_REGION: us-east-1
  APPLICATION_NAME: resilienceatlas
  DEPLOYMENT_GROUP: resilienceatlas-staging

concurrency:
  group: staging-deployment
  cancel-in-progress: true

# Required for OIDC authentication with AWS
permissions:
  id-token: write
  contents: read

jobs:
  build-images:
    name: Build ${{ matrix.service }} image
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: staging
    
    strategy:
      matrix:
        service: [backend, frontend]
    
    outputs:
      backend-image: ${{ steps.set-output.outputs.backend-image }}
      frontend-image: ${{ steps.set-output.outputs.frontend-image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
        role-session-name: GitHubActionsStagingBuild-${{ matrix.service }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment info
      id: deployment-info
      run: |
        echo "short-sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: image=moby/buildkit:buildx-stable-1

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set ECR repository name
      id: ecr-repo
      run: |
        echo "repo-name=resilienceatlas/${{ matrix.service }}" >> $GITHUB_OUTPUT

    - name: Create ECR repository if it doesn't exist
      run: |
        REPO="${{ steps.ecr-repo.outputs.repo-name }}"
        if ! aws ecr describe-repositories --repository-names "$REPO" 2>/dev/null; then
          echo "Creating ECR repository: $REPO"
          aws ecr create-repository \
            --repository-name "$REPO" \
            --image-scanning-configuration scanOnPush=true \
            --image-tag-mutability MUTABLE
        else
          echo "ECR repository exists: $REPO"
        fi

    - name: Build and push ${{ matrix.service }} image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: staging-${{ steps.deployment-info.outputs.short-sha }}
      run: |
        # Set build args for frontend
        BUILD_ARGS=""
        if [ "${{ matrix.service }}" = "frontend" ]; then
          BUILD_ARGS="--build-arg NEXT_PUBLIC_API_HOST=https://staging.resilienceatlas.org \
            --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS }} \
            --build-arg NEXT_PUBLIC_TRANSIFEX_TOKEN=${{ secrets.NEXT_PUBLIC_TRANSIFEX_TOKEN }} \
            --build-arg NEXT_PUBLIC_TRANSIFEX_SECRET=${{ secrets.NEXT_PUBLIC_TRANSIFEX_SECRET }} \
            --build-arg NEXT_PUBLIC_GOOGLE_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_API_KEY }}"
        fi
        
        docker buildx build \
          --cache-from=type=gha,scope=${{ matrix.service }}-staging \
          --cache-to=type=gha,mode=max,scope=${{ matrix.service }}-staging \
          --target production \
          $BUILD_ARGS \
          --tag $ECR_REGISTRY/${{ steps.ecr-repo.outputs.repo-name }}:$IMAGE_TAG \
          --tag $ECR_REGISTRY/${{ steps.ecr-repo.outputs.repo-name }}:staging-latest \
          --push \
          ./${{ matrix.service }}
        
        IMAGE_REF="$ECR_REGISTRY/${{ steps.ecr-repo.outputs.repo-name }}:$IMAGE_TAG"
        echo "${{ matrix.service }}-image=$IMAGE_REF" >> $GITHUB_OUTPUT
        echo "‚úÖ ${{ matrix.service }} image pushed to ECR: $IMAGE_REF"
      id: build-push
    
    - name: Set output for job
      id: set-output
      run: |
        if [ "${{ matrix.service }}" = "backend" ]; then
          echo "backend-image=${{ steps.build-push.outputs.backend-image }}" >> $GITHUB_OUTPUT
        elif [ "${{ matrix.service }}" = "frontend" ]; then
          echo "frontend-image=${{ steps.build-push.outputs.frontend-image }}" >> $GITHUB_OUTPUT
        fi

  deploy:
    name: Deploy to Staging via CodeDeploy
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: staging
    needs: build-images

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
        role-session-name: GitHubActionsStagingDeploy
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment info
      id: deployment-info
      run: |
        echo "commit-sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "short-sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
        echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        echo "s3-bucket=${{ secrets.DEPLOYMENT_S3_BUCKET }}" >> $GITHUB_OUTPUT

    - name: Verify S3 bucket exists
      run: |
        BUCKET_NAME="${{ steps.deployment-info.outputs.s3-bucket }}"
        if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
          echo "‚ùå S3 bucket does not exist: $BUCKET_NAME"
          echo "Please run scripts/setup_s3_bucket.py to create it first."
          exit 1
        fi
        echo "‚úÖ S3 bucket exists: $BUCKET_NAME"

    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Get built image references
      id: images
      run: |
        # Images were built in parallel by the build-images job
        echo "backend-image=${{ needs.build-images.outputs.backend-image }}" >> $GITHUB_OUTPUT
        echo "frontend-image=${{ needs.build-images.outputs.frontend-image }}" >> $GITHUB_OUTPUT
        echo "‚úÖ Backend image: ${{ needs.build-images.outputs.backend-image }}"
        echo "‚úÖ Frontend image: ${{ needs.build-images.outputs.frontend-image }}"

    - name: Create environment file for deployment
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        BACKEND_IMAGE: ${{ steps.images.outputs.backend-image }}
        FRONTEND_IMAGE: ${{ steps.images.outputs.frontend-image }}
      run: |
        # Generate .env.staging with secrets from GitHub
        # This file is included in the deployment package and copied to the server
        cat > .env.staging << EOF
        # Generated by GitHub Actions on $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        # Commit: ${{ github.sha }}
        
        # ECR Images (pre-built in CI)
        ECR_REGISTRY=$ECR_REGISTRY
        BACKEND_IMAGE=$BACKEND_IMAGE
        FRONTEND_IMAGE=$FRONTEND_IMAGE
        
        # Rails/Node environment
        RAILS_ENV=staging
        NODE_ENV=production
        
        # Database (Docker container)
        DATABASE_HOST=database
        DATABASE_PORT=5432
        DATABASE_NAME=resilienceatlas_staging
        DATABASE_USER=postgres
        DATABASE_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}
        POSTGRES_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}
        
        # Rails secrets
        SECRET_KEY_BASE=${{ secrets.STAGING_SECRET_KEY_BASE }}
        DEVISE_SECRET_KEY=${{ secrets.STAGING_DEVISE_KEY }}
        
        # Application URLs
        BACKEND_URL=https://staging.resilienceatlas.org
        FRONTEND_URL=https://staging.resilienceatlas.org
        NEXT_PUBLIC_API_HOST=https://staging.resilienceatlas.org
        
        # External services
        NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS }}
        NEXT_PUBLIC_TRANSIFEX_TOKEN=${{ secrets.NEXT_PUBLIC_TRANSIFEX_TOKEN }}
        NEXT_PUBLIC_TRANSIFEX_SECRET=${{ secrets.NEXT_PUBLIC_TRANSIFEX_SECRET }}
        NEXT_PUBLIC_GOOGLE_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_API_KEY }}
        RESILIENCE_API_KEY=${{ secrets.RESILIENCE_API_KEY }}
        SPARKPOST_API_KEY=${{ secrets.SPARKPOST_API_KEY }}
        
        # Error tracking
        ROLLBAR_ACCESS_TOKEN=${{ secrets.ROLLBAR_ACCESS_TOKEN }}
        NEXT_PUBLIC_ROLLBAR_CLIENT_TOKEN=${{ secrets.NEXT_PUBLIC_ROLLBAR_CLIENT_TOKEN }}
        ROLLBAR_ENV=staging
        
        # Database sync configuration
        PRODUCTION_DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
        SYNC_PRODUCTION_DB=${{ github.event.inputs.sync_database || 'true' }}
        
        # Storage file sync configuration (syncs images from production to staging)
        # Use "localhost" when both environments are on the same server (copies between Docker volumes)
        # Use a remote hostname/IP if production is on a different server (requires SSH access)
        PRODUCTION_BACKEND_HOST=${{ secrets.PRODUCTION_BACKEND_HOST || 'localhost' }}
        SYNC_STORAGE_FILES=true
        
        # Deployment info
        GIT_REVISION=${{ github.sha }}
        EOF
        
        # Remove leading whitespace from each line (heredoc indentation issue)
        sed -i 's/^        //' .env.staging
        
        echo "‚úÖ Created .env.staging with $(wc -l < .env.staging) lines"

    - name: Update appspec.yml for staging
      run: |
        # Modify appspec.yml to use staging-specific destination
        # This prevents race conditions when staging and production deploy simultaneously
        sed -i 's|destination: /opt/resilienceatlas|destination: /opt/resilienceatlas-staging|g' appspec.yml
        sed -i 's|object: /opt/resilienceatlas|object: /opt/resilienceatlas-staging|g' appspec.yml
        echo "Updated appspec.yml destination to /opt/resilienceatlas-staging"
        cat appspec.yml

    - name: Create deployment package
      run: |
        # Create a deployment archive
        REVISION_FILE="staging-${{ steps.deployment-info.outputs.timestamp }}-${{ steps.deployment-info.outputs.short-sha }}.zip"
        echo "revision-file=$REVISION_FILE" >> $GITHUB_OUTPUT
        
        # Exclude files not needed for deployment
        zip -r "$REVISION_FILE" . \
          -x ".git/*" \
          -x "node_modules/*" \
          -x "*.log" \
          -x ".env.example" \
          -x ".env.test" \
          -x "frontend/node_modules/*" \
          -x "frontend/.next/*" \
          -x "backend/tmp/*" \
          -x "backend/log/*" \
          -x "data/*" \
          -x "integration-tests/*" \
          -x "*.md" \
          -x "LICENSE"
        
        echo "Created deployment package: $REVISION_FILE ($(du -h $REVISION_FILE | cut -f1))"
      id: package

    - name: Upload deployment package to S3
      run: |
        BUCKET="${{ steps.deployment-info.outputs.s3-bucket }}"
        KEY="staging/${{ steps.package.outputs.revision-file }}"
        
        aws s3 cp "${{ steps.package.outputs.revision-file }}" "s3://$BUCKET/$KEY"
        
        echo "s3-key=$KEY" >> $GITHUB_OUTPUT
        echo "Uploaded to s3://$BUCKET/$KEY"
      id: upload

    - name: Stop any in-progress deployments
      run: |
        echo "üîç Checking for in-progress deployments..."
        
        # Get list of active deployments
        # Valid statuses: Created, Queued, InProgress, Baking, Succeeded, Failed, Stopped, Ready
        ACTIVE_DEPLOYMENTS=$(aws deploy list-deployments \
          --application-name ${{ env.APPLICATION_NAME }} \
          --deployment-group-name ${{ env.DEPLOYMENT_GROUP }} \
          --include-only-statuses "InProgress" "Queued" "Created" \
          --query 'deployments' \
          --output text)
        
        if [ -n "$ACTIVE_DEPLOYMENTS" ] && [ "$ACTIVE_DEPLOYMENTS" != "None" ]; then
          for DEPLOYMENT_ID in $ACTIVE_DEPLOYMENTS; do
            echo "‚èπÔ∏è Stopping deployment: $DEPLOYMENT_ID"
            aws deploy stop-deployment \
              --deployment-id "$DEPLOYMENT_ID" \
              --auto-rollback-enabled || echo "  (already stopping or stopped)"
          done
          
          # Poll until all deployments reach a terminal state
          echo "‚è≥ Waiting for deployments to fully stop..."
          for DEPLOYMENT_ID in $ACTIVE_DEPLOYMENTS; do
            WAIT_COUNT=0
            MAX_WAIT=60  # 60 iterations √ó 5 seconds = 5 minutes max
            while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
              STATUS=$(aws deploy get-deployment \
                --deployment-id "$DEPLOYMENT_ID" \
                --query 'deploymentInfo.status' \
                --output text)
              
              echo "  $DEPLOYMENT_ID: $STATUS"
              
              # Terminal states - deployment is no longer blocking
              if [[ "$STATUS" == "Stopped" || "$STATUS" == "Failed" || "$STATUS" == "Succeeded" ]]; then
                break
              fi
              
              sleep 5
              WAIT_COUNT=$((WAIT_COUNT + 1))
            done
            
            if [ $WAIT_COUNT -ge $MAX_WAIT ]; then
              echo "‚ö†Ô∏è Timed out waiting for $DEPLOYMENT_ID to stop"
            fi
          done
          echo "‚úÖ All previous deployments stopped"
        else
          echo "‚úÖ No active deployments found"
        fi

    - name: Create CodeDeploy deployment
      id: deploy
      run: |
        BUCKET="${{ steps.deployment-info.outputs.s3-bucket }}"
        KEY="${{ steps.upload.outputs.s3-key }}"
        
        DEPLOYMENT_ID=$(aws deploy create-deployment \
          --application-name ${{ env.APPLICATION_NAME }} \
          --deployment-group-name ${{ env.DEPLOYMENT_GROUP }} \
          --s3-location bucket=$BUCKET,key=$KEY,bundleType=zip \
          --deployment-config-name CodeDeployDefault.OneAtATime \
          --description "Staging deployment: ${{ github.sha }} from ${{ github.ref_name }}" \
          --file-exists-behavior OVERWRITE \
          --query 'deploymentId' \
          --output text)
        
        echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        echo "üöÄ Created deployment: $DEPLOYMENT_ID"

    - name: Wait for deployment to complete
      run: |
        DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment-id }}"
        echo "‚è≥ Waiting for deployment $DEPLOYMENT_ID to complete..."
        
        # Wait for deployment (max 30 minutes)
        aws deploy wait deployment-successful \
          --deployment-id "$DEPLOYMENT_ID" \
          --cli-read-timeout 1800 || {
            # Get deployment info if failed
            STATUS=$(aws deploy get-deployment --deployment-id "$DEPLOYMENT_ID" \
              --query 'deploymentInfo.status' --output text)
            
            echo "‚ùå Deployment failed with status: $STATUS"
            
            # Get deployment events for debugging
            echo "üìã Deployment events:"
            aws deploy list-deployment-targets --deployment-id "$DEPLOYMENT_ID" \
              --query 'targetIds' --output text | while read TARGET_ID; do
              echo "Target: $TARGET_ID"
              aws deploy get-deployment-target \
                --deployment-id "$DEPLOYMENT_ID" \
                --target-id "$TARGET_ID" \
                --query 'deploymentTarget.instanceTarget.lifecycleEvents[*].{Event:lifecycleEventName,Status:status,Message:diagnostics.message}' \
                --output table
            done
            
            exit 1
          }
        
        echo "‚úÖ Deployment completed successfully!"

    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        
        # Get deployment status
        DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment-id }}"
        aws deploy get-deployment \
          --deployment-id "$DEPLOYMENT_ID" \
          --query 'deploymentInfo.{Status:status,CreateTime:createTime,CompleteTime:completeTime}' \
          --output table

    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ Staging deployment successful!"
          echo "üåê Site: https://staging.resilienceatlas.org"
          echo "üì¶ Commit: ${{ github.sha }}"
          echo "üöÄ Deployment ID: ${{ steps.deploy.outputs.deployment-id }}"
        else
          echo "‚ùå Staging deployment failed!"
          echo "üì¶ Commit: ${{ github.sha }}"
          echo "üöÄ Deployment ID: ${{ steps.deploy.outputs.deployment-id }}"
          exit 1
        fi

    - name: Notify Rollbar of deployment
      if: success()
      run: |
        # Notify Rollbar of successful deployment (if token is configured)
        if [ -n "${{ secrets.ROLLBAR_ACCESS_TOKEN }}" ]; then
          curl -s https://api.rollbar.com/api/1/deploy \
            -F access_token=${{ secrets.ROLLBAR_ACCESS_TOKEN }} \
            -F environment=staging \
            -F revision=${{ github.sha }} \
            -F rollbar_username="${{ github.actor }}" \
            -F local_username="${{ github.actor }}" \
            -F comment="Staging deployment via GitHub Actions - ${{ github.ref_name }}" \
            -F status=succeeded
          echo "üìä Rollbar deployment notification sent"
        else
          echo "‚ö†Ô∏è ROLLBAR_ACCESS_TOKEN not configured, skipping deployment notification"
        fi
