# Integration tests with Cypress - download.cypress.io now allowlisted
name: Integration Tests

on:
  push:
    branches:
      - develop
      - main
  pull_request:
    branches:
      - develop
      - main
  workflow_dispatch:

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  integration-tests:
    name: Full Stack Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 60

    strategy:
      matrix:
        browser: [chrome, firefox]
      fail-fast: false

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure DNS for better connectivity
      run: |
        echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf.backup > /dev/null
        echo "nameserver 1.1.1.1" | sudo tee -a /etc/resolv.conf.backup > /dev/null  
        sudo cp /etc/resolv.conf.backup /etc/resolv.conf
        echo "üîß DNS configuration updated"

    - name: Check network connectivity
      run: |
        echo "üîç Checking network connectivity..."
        echo "Testing registry.npmjs.org:"
        curl -I https://registry.npmjs.org/ || echo "‚ùå npm registry not reachable"
        echo "Testing github.com:"
        curl -I https://github.com/ || echo "‚ùå GitHub not reachable"
        echo "Testing docker.io:"
        curl -I https://registry-1.docker.io/ || echo "‚ùå Docker registry not reachable"
        echo "Testing download.cypress.io:"
        curl -I https://download.cypress.io/ || echo "‚ùå Cypress downloads not reachable"
        echo "Testing cdn.cypress.io:"
        curl -I https://cdn.cypress.io/desktop/13.17.0/linux-x64/cypress.zip || echo "‚ùå Cypress binary CDN not reachable"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: image=moby/buildkit:buildx-stable-1

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-integration-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-integration-buildx-

    - name: Create test environment file
      run: |
        cat > .env.test << EOF
        # Backend environment
        RAILS_ENV=test
        DATABASE_URL=postgres://postgres:postgres@db-test:5432/resilienceatlas_integration_test
        DATABASE_HOST=db-test
        DATABASE_PORT=5432
        DATABASE_NAME=resilienceatlas_integration_test
        DATABASE_USER=postgres
        DATABASE_PASSWORD=postgres
        SECRET_KEY_BASE=integration_test_secret_key_base_that_is_long_enough_for_rails_to_accept_it_properly
        DEVISE_KEY=integration_test_devise_key_that_is_also_long_enough_for_the_application_to_work
        REDIS_URL=redis://redis-test:6379/1
        BACKEND_URL=http://backend-test:3001
        FRONTEND_URL=http://frontend-test:3000
        CORS_ORIGINS=http://frontend-test:3000,http://localhost:3000
        
        # Frontend environment
        NODE_ENV=test
        NEXT_PUBLIC_API_HOST=http://backend-test:3001
        NEXT_PUBLIC_GOOGLE_ANALYTICS=GA_INTEGRATION_TEST_ID
        NEXT_PUBLIC_TRANSIFEX_TOKEN=integration_test_token
        NEXT_PUBLIC_TRANSIFEX_SECRET=integration_test_secret
        NEXT_PUBLIC_GOOGLE_API_KEY=integration_test_api_key
        PORT=3000
        EOF

    - name: Build backend test image
      run: |
        # Retry Docker build up to 3 times in case of network issues
        for i in {1..3}; do
          echo "Build attempt $i of 3"
          if docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --target test \
            --tag resilienceatlas-backend:integration-test \
            --load \
            ./backend; then
            echo "‚úÖ Backend build successful on attempt $i"
            break
          elif [ $i -eq 3 ]; then
            echo "‚ùå Backend build failed after 3 attempts"
            exit 1
          else
            echo "‚ö†Ô∏è Backend build attempt $i failed, retrying in 30 seconds..."
            sleep 30
          fi
        done

    - name: Build frontend test image
      run: |
        # Retry Docker build up to 3 times in case of network issues  
        for i in {1..3}; do
          echo "Build attempt $i of 3"
          if docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --target test \
            --build-arg NEXT_PUBLIC_API_HOST=http://backend-test:3001 \
            --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS=GA_INTEGRATION_TEST_ID \
            --build-arg NEXT_PUBLIC_TRANSIFEX_TOKEN=integration_test_token \
            --build-arg NEXT_PUBLIC_TRANSIFEX_SECRET=integration_test_secret \
            --build-arg NEXT_PUBLIC_GOOGLE_API_KEY=integration_test_api_key \
            --tag resilienceatlas-frontend:integration-test \
            --load \
            ./frontend; then
            echo "‚úÖ Frontend build successful on attempt $i"
            break
          elif [ $i -eq 3 ]; then
            echo "‚ùå Frontend build failed after 3 attempts"
            exit 1
          else
            echo "‚ö†Ô∏è Frontend build attempt $i failed, retrying in 30 seconds..."
            sleep 30
          fi
        done

    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache

    - name: Start infrastructure services
      run: |
        # Start database and Redis
        docker compose -f docker-compose.test.yml up -d db-test redis-test
        
        # Wait for database to be ready
        timeout 60s bash -c 'until docker compose -f docker-compose.test.yml exec -T db-test pg_isready -U postgres; do sleep 2; done'
        
        echo "‚úÖ Infrastructure services started"

    - name: Setup and start backend
      run: |
        # Ensure clean state
        docker compose -f docker-compose.test.yml down -v
        
        # Create and setup database with better error handling
        echo "Setting up test database..."
        docker compose -f docker-compose.test.yml run --rm backend-test \
          bash -c "
            # Use Rails built-in database preparation which handles existing schemas better
            echo 'Preparing database...'
            RAILS_ENV=test bundle exec rails db:environment:set RAILS_ENV=test || true &&
            RAILS_ENV=test bundle exec rails db:prepare &&
            echo 'Database prepared successfully'
            
            # Only seed if tables are empty
            if RAILS_ENV=test bundle exec rails runner 'puts Site.count' | grep -q '^0$'; then
              echo 'Seeding database...'
              RAILS_ENV=test bundle exec rails db:seed
            else
              echo 'Database already contains data, skipping seed'
            fi
          "
        
        # Start backend service in background
        docker compose -f docker-compose.test.yml up -d backend-test
        
        # Wait for backend to be ready with enhanced health check
        echo "Waiting for backend to be ready..."
        timeout 180s bash -c '
          attempt=1
          while [ $attempt -le 36 ]; do
            echo "Health check attempt $attempt/36..."
            if curl -f -s http://localhost:3001/api/health >/dev/null 2>&1; then
              echo "‚úÖ Backend health check passed"
              break
            elif [ $attempt -eq 36 ]; then
              echo "‚ùå Backend failed to become healthy after 3 minutes"
              echo "Backend logs:"
              docker compose -f docker-compose.test.yml logs backend-test --tail=50
              exit 1
            else
              echo "Backend not ready yet, waiting 5 seconds..."
              sleep 5
              attempt=$((attempt + 1))
            fi
          done
        '
        
        echo "‚úÖ Backend service started and healthy"

    - name: Verify backend API endpoints
      run: |
        # Test core API endpoints
        echo "Testing backend API endpoints..."
        
        # Health check
        curl -f http://localhost:3001/api/health
        
        # Test API root
        curl -f http://localhost:3001/api/v1/
        
        echo "‚úÖ Backend API endpoints verified"

    - name: Start frontend service
      run: |
        # Start frontend service
        docker compose -f docker-compose.test.yml up -d frontend-test
        
        # Wait for frontend to be ready with enhanced monitoring
        echo "Waiting for frontend to be ready..."
        timeout 300s bash -c '
          attempt=1
          while [ $attempt -le 60 ]; do
            echo "Frontend check attempt $attempt/60..."
            if curl -f -s -o /dev/null -w "%{http_code}" http://localhost:3000 | grep -q "200"; then
              echo "‚úÖ Frontend responding with 200 OK"
              break
            elif [ $attempt -eq 60 ]; then
              echo "‚ùå Frontend failed to start after 5 minutes"
              echo "Frontend logs:"
              docker compose -f docker-compose.test.yml logs frontend-test --tail=50
              echo "Frontend container status:"
              docker compose -f docker-compose.test.yml ps frontend-test
              exit 1
            else
              response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000")
              echo "Frontend not ready yet (HTTP $response), waiting 5 seconds..."
              sleep 5
              attempt=$((attempt + 1))
            fi
          done
        '
        
        echo "‚úÖ Frontend service started and responding"

    - name: Verify full stack connectivity
      run: |
        # Test that frontend can reach backend
        echo "Testing full stack connectivity..."
        
        # Check if frontend loads
        response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
        if [ "$response" != "200" ]; then
          echo "‚ùå Frontend not responding correctly: $response"
          exit 1
        fi
        
        # Test API calls from frontend perspective
        docker compose -f docker-compose.test.yml exec -T frontend-test \
          curl -f http://backend-test:3001/api/health
        
        echo "‚úÖ Full stack connectivity verified"

    - name: Run API integration tests
      run: |
        # Run backend API tests that verify frontend-backend integration
        docker compose -f docker-compose.test.yml run --rm backend-test \
          bash -c "
            RAILS_ENV=test bundle exec rspec spec/integration \
              --format RspecJunitFormatter \
              --out tmp/integration-rspec.xml \
              --format progress
          "

    - name: Run end-to-end integration tests
      run: |
        # Run Cypress integration tests with enhanced error handling
        echo "Starting Cypress integration tests for ${{ matrix.browser }}..."
        docker compose -f docker-compose.test.yml run --rm \
          -e CYPRESS_baseUrl=http://frontend-test:3000 \
          -e CYPRESS_apiUrl=http://backend-test:3001 \
          -e CYPRESS_video=true \
          -e CYPRESS_screenshotOnRunFailure=true \
          cypress-${{ matrix.browser }} \
          bash -c "
            echo 'Verifying Cypress environment...'
            npx cypress version
            
            echo 'Verifying connectivity to test services...'
            curl -f http://frontend-test:3000 || { echo 'Frontend not reachable'; exit 1; }
            curl -f http://backend-test:3001/api/health || { echo 'Backend API not reachable'; exit 1; }
            
            echo 'Starting Cypress tests...'
            npx cypress run \
              --browser ${{ matrix.browser }} \
              --headless \
              --config video=true,screenshotOnRunFailure=true,defaultCommandTimeout=10000,requestTimeout=10000,responseTimeout=30000 \
              --reporter junit \
              --reporter-options mochaFile=cypress/results/integration-${{ matrix.browser }}-[hash].xml
          " || {
            echo "‚ùå Cypress tests failed for ${{ matrix.browser }}"
            echo "Collecting debug information..."
            echo "=== Frontend Logs ==="
            docker compose -f docker-compose.test.yml logs frontend-test --tail=50
            echo "=== Backend Logs ==="
            docker compose -f docker-compose.test.yml logs backend-test --tail=50
            exit 1
          }

    - name: Run performance tests
      run: |
        # Basic performance test using curl and timing
        echo "Running basic performance tests..."
        
        # Test backend response times
        echo "Testing backend performance..."
        for i in {1..5}; do
          time curl -s http://localhost:3001/api/health > /dev/null
        done
        
        # Test frontend response times
        echo "Testing frontend performance..."
        for i in {1..5}; do
          time curl -s http://localhost:3000 > /dev/null
        done
        
        echo "‚úÖ Performance tests completed"

    - name: Test data consistency
      run: |
        # Test that data flows correctly between frontend and backend
        echo "Testing data consistency..."
        
        # Create test data via API
        docker compose -f docker-compose.test.yml run --rm backend-test \
          bash -c "
            RAILS_ENV=test bundle exec rails runner '
              # Create test data and verify it can be retrieved
              puts \"Creating test data...\"
              # Add specific test data creation here based on your models
              puts \"Test data created successfully\"
            '
          "
        
        echo "‚úÖ Data consistency tests completed"

    - name: Collect service logs
      if: failure()
      run: |
        echo "=== Backend Logs ==="
        docker compose -f docker-compose.test.yml logs backend-test --tail=100
        echo "=== Frontend Logs ==="
        docker compose -f docker-compose.test.yml logs frontend-test --tail=100
        echo "=== Database Logs ==="
        docker compose -f docker-compose.test.yml logs db-test --tail=50

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Integration Tests (${{ matrix.browser }})
        path: |
          backend/tmp/integration-rspec.xml
          frontend/cypress/results/*.xml
        reporter: java-junit

    - name: Upload integration test artifacts
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: integration-test-artifacts-${{ matrix.browser }}
        path: |
          frontend/cypress/videos
          frontend/cypress/screenshots
          backend/tmp/
        retention-days: 7

    - name: Cleanup
      if: always()
      run: |
        docker compose -f docker-compose.test.yml down -v
        docker system prune -f

  integration-summary:
    name: Integration Test Summary
    runs-on: ubuntu-latest
    needs: integration-tests
    if: always()
    
    steps:
    - name: Check integration test results
      run: |
        if [ "${{ needs.integration-tests.result }}" = "success" ]; then
          echo "‚úÖ All integration tests passed successfully!"
        else
          echo "‚ùå Some integration tests failed"
          exit 1
        fi
