name: ECS Deploy - Staging

on:
  push:
    branches:
      - develop
  workflow_dispatch:
  workflow_run:
    workflows: ["Frontend Tests", "Backend Tests"]
    branches: [develop]
    types: [completed]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_FRONTEND: resilienceatlas-frontend
  ECR_REPOSITORY_BACKEND: resilienceatlas-backend
  ECR_REPOSITORY_DATABASE: resilienceatlas-database-staging
  ECS_SERVICE_FRONTEND: resilienceatlas-frontend-staging
  ECS_SERVICE_BACKEND: resilienceatlas-backend-staging
  ECS_CLUSTER: resilienceatlas-cluster
  FRONTEND_CONTAINER_NAME: frontend
  BACKEND_CONTAINER_NAME: backend
  DATABASE_CONTAINER_NAME: database

jobs:
  build-and-deploy:
    name: Build and Deploy to ECS Staging
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup staging database container and copy production data
      run: |
        echo "üóÑÔ∏è Setting up containerized staging database with production data..."
        
        # Get production database connection details
        PROD_DB_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
        
        # Parse production database URL
        PROD_DB_HOST=$(echo $PROD_DB_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
        PROD_DB_PORT=$(echo $PROD_DB_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
        PROD_DB_NAME=$(echo $PROD_DB_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
        PROD_DB_USER=$(echo $PROD_DB_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
        PROD_DB_PASS=$(echo $PROD_DB_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
        
        # Install PostgreSQL client tools
        sudo apt-get update
        sudo apt-get install -y postgresql-client-15
        
        echo "üìä Production DB: $PROD_DB_HOST:$PROD_DB_PORT/$PROD_DB_NAME"
        
        # Test connection to production database
        echo "Testing production database connection..."
        PGPASSWORD="$PROD_DB_PASS" psql -h "$PROD_DB_HOST" -p "$PROD_DB_PORT" -U "$PROD_DB_USER" -d "$PROD_DB_NAME" -c "SELECT version();" > /dev/null
        
        # Create temporary dump file
        DUMP_FILE="/tmp/production_dump_$(date +%Y%m%d_%H%M%S).sql"
        
        # Dump production database with filtered tables
        echo "üíæ Creating filtered dump of production database..."
        PGPASSWORD="$PROD_DB_PASS" pg_dump \
          -h "$PROD_DB_HOST" \
          -p "$PROD_DB_PORT" \
          -U "$PROD_DB_USER" \
          -d "$PROD_DB_NAME" \
          --verbose \
          --no-owner \
          --no-privileges \
          --exclude-table-data=action_text_rich_texts \
          --exclude-table-data=active_storage_blobs \
          --exclude-table-data=active_storage_attachments \
          --exclude-table-data=logs \
          --exclude-table-data=audit_logs \
          --exclude-table-data=versions \
          > "$DUMP_FILE"
        
        # Check dump file size
        DUMP_SIZE=$(du -h "$DUMP_FILE" | cut -f1)
        echo "üì¶ Dump file created: $DUMP_SIZE"
        
        # Create Docker network for staging
        docker network create staging-network || true
        
        # Start PostgreSQL container for staging
        echo "ÔøΩ Starting PostgreSQL container for staging..."
        docker run -d \
          --name staging-postgres \
          --network staging-network \
          -p 5434:5432 \
          -e POSTGRES_DB=resilienceatlas_staging \
          -e POSTGRES_USER=postgres \
          -e POSTGRES_PASSWORD=staging_password \
          -v staging_postgres_data:/var/lib/postgresql/data \
          postgis/postgis:15-3.3
        
        # Wait for database to be ready
        echo "‚è≥ Waiting for staging database to be ready..."
        timeout 60s bash -c 'until docker exec staging-postgres pg_isready -U postgres; do sleep 2; done'
        
        # Enable PostGIS extensions
        echo "üó∫Ô∏è Enabling PostGIS extensions..."
        docker exec staging-postgres psql -U postgres -d resilienceatlas_staging -c "CREATE EXTENSION IF NOT EXISTS postgis; CREATE EXTENSION IF NOT EXISTS postgis_topology;"
        
        # Restore production data to staging container
        echo "üì• Restoring production data to staging container..."
        docker exec -i staging-postgres psql -U postgres -d resilienceatlas_staging < "$DUMP_FILE"
        
        # Verify staging database
        echo "‚úÖ Verifying staging database..."
        STAGING_TABLE_COUNT=$(docker exec staging-postgres psql -U postgres -d resilienceatlas_staging -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
        
        echo "üìã Staging database container now contains $STAGING_TABLE_COUNT tables"
        
        # Clean up dump file
        rm "$DUMP_FILE"
        
        # Create application user and configure database for ECS
        echo "üë§ Creating application user and configuring database..."
        docker exec staging-postgres psql -U postgres -d resilienceatlas_staging -c "
        DO \$\$
        BEGIN
          IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'resilienceatlas') THEN
            CREATE USER resilienceatlas WITH PASSWORD 'staging_db_password_CHANGE_ME';
            GRANT ALL PRIVILEGES ON DATABASE resilienceatlas_staging TO resilienceatlas;
            GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO resilienceatlas;
            GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO resilienceatlas;
          END IF;
        END
        \$\$;
        "
        
        # Tag and prepare database container for ECR
        echo "üè∑Ô∏è Preparing database container for deployment..."
        
        # Commit the container with data to create a new image
        docker commit staging-postgres staging-postgres-with-data:latest
        
        # Stop the temporary container
        docker stop staging-postgres
        docker rm staging-postgres
        
        echo "‚úÖ Staging database container prepared successfully!"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Tag and push staging database image to Amazon ECR
      id: build-database-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Tag the prepared database container for ECR
        docker tag staging-postgres-with-data:latest $ECR_REGISTRY/$ECR_REPOSITORY_DATABASE:$IMAGE_TAG
        docker tag staging-postgres-with-data:latest $ECR_REGISTRY/$ECR_REPOSITORY_DATABASE:latest
        
        # Push database image to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_DATABASE:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_DATABASE:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_DATABASE:$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        # Clean up local database image
        docker rmi staging-postgres-with-data:latest
        docker volume rm staging_postgres_data || true
        docker network rm staging-network || true

    - name: Build, tag, and push frontend image to Amazon ECR
      id: build-frontend-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build frontend image using production target
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG \
          --target production \
          --build-arg NEXT_PUBLIC_API_HOST=${{ secrets.STAGING_NEXT_PUBLIC_API_HOST }} \
          --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS }} \
          --build-arg NEXT_PUBLIC_TRANSIFEX_TOKEN=${{ secrets.NEXT_PUBLIC_TRANSIFEX_TOKEN }} \
          --build-arg NEXT_PUBLIC_TRANSIFEX_SECRET=${{ secrets.NEXT_PUBLIC_TRANSIFEX_SECRET }} \
          --build-arg NEXT_PUBLIC_GOOGLE_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_API_KEY }} \
          ./frontend
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Build, tag, and push backend image to Amazon ECR
      id: build-backend-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build backend image using production target
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG \
          --target production \
          ./backend
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Fill in the new database image ID in the Amazon ECS task definition
      id: task-def-backend-database
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: .aws/task-definition-backend-staging.json
        container-name: database
        image: ${{ steps.build-database-image.outputs.image }}

    - name: Fill in the new backend image ID in the Amazon ECS task definition
      id: task-def-backend-final
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: ${{ steps.task-def-backend-database.outputs.task-definition }}
        container-name: ${{ env.BACKEND_CONTAINER_NAME }}
        image: ${{ steps.build-backend-image.outputs.image }}

    - name: Fill in the new frontend image ID in the Amazon ECS task definition
      id: task-def-frontend
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: .aws/task-definition-frontend-staging.json
        container-name: ${{ env.FRONTEND_CONTAINER_NAME }}
        image: ${{ steps.build-frontend-image.outputs.image }}

    - name: Fill in the new backend image ID in the Amazon ECS task definition
      id: task-def-backend
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: .aws/task-definition-backend-staging.json
        container-name: ${{ env.BACKEND_CONTAINER_NAME }}
        image: ${{ steps.build-backend-image.outputs.image }}

    - name: Deploy Amazon ECS frontend task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def-frontend.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_FRONTEND }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Deploy Amazon ECS backend task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def-backend-final.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_BACKEND }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ Staging deployment successful! Frontend: staging.resilienceatlas.org"
        else
          echo "‚ùå Staging deployment failed!"
          exit 1
        fi
