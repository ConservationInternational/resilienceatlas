name: EC2 Deploy - Staging

on:
  push:
    branches:
      - develop
  workflow_dispatch:
  workflow_run:
    workflows: ["Frontend Tests", "Backend Tests"]
    branches: [develop]
    types: [completed]

env:
  AWS_REGION: us-east-1

jobs:
  build-and-deploy:
    name: Build and Deploy to EC2 Staging
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get runner IP and update security group
      id: security-group
      run: |
        # Get the public IP of the GitHub Actions runner
        RUNNER_IP=$(curl -s https://checkip.amazonaws.com)
        echo "Runner IP: $RUNNER_IP"
        echo "runner-ip=$RUNNER_IP" >> $GITHUB_OUTPUT
        
        # Add SSH access rule for the runner IP
        echo "Adding SSH access for runner IP $RUNNER_IP to security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
        aws ec2 authorize-security-group-ingress \
          --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
          --protocol tcp \
          --port 22 \
          --cidr "${RUNNER_IP}/32" || true
        
        echo "Security group rule added successfully"

    - name: Set SSH port variable
      id: ssh-port
      run: |
        # Trim whitespace and newlines from the port
        PORT="${{ secrets.STAGING_SSH_PORT || 22 }}"
        PORT=$(echo "$PORT" | tr -d '[:space:]')
        echo "port=$PORT" >> $GITHUB_OUTPUT

    - name: Setup staging database with production data
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üóÑÔ∏è Setting up staging database with production data..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/resilienceatlas-staging' }}
          
          # Install PostgreSQL client if not present
          if ! command -v psql &> /dev/null; then
            echo "üì¶ Installing PostgreSQL client..."
            sudo apt-get update
            sudo apt-get install -y postgresql-client-15
          fi
          
          # Get production database connection details from secrets
          PROD_DB_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
          
          # Parse production database URL
          PROD_DB_HOST=$(echo $PROD_DB_URL | sed -n 's/.*@\([^:]*\):.*/\1/p')
          PROD_DB_PORT=$(echo $PROD_DB_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
          PROD_DB_NAME=$(echo $PROD_DB_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')
          PROD_DB_USER=$(echo $PROD_DB_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
          PROD_DB_PASS=$(echo $PROD_DB_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
          
          echo "üìä Production DB: $PROD_DB_HOST:$PROD_DB_PORT/$PROD_DB_NAME"
          
          # Test connection to production database
          echo "Testing production database connection..."
          PGPASSWORD="$PROD_DB_PASS" psql -h "$PROD_DB_HOST" -p "$PROD_DB_PORT" -U "$PROD_DB_USER" -d "$PROD_DB_NAME" -c "SELECT version();" > /dev/null
          
          # Create temporary dump file
          DUMP_FILE="/tmp/production_dump_$(date +%Y%m%d_%H%M%S).sql"
          
          # Dump production database with filtered tables
          echo "üíæ Creating filtered dump of production database..."
          PGPASSWORD="$PROD_DB_PASS" pg_dump \
            -h "$PROD_DB_HOST" \
            -p "$PROD_DB_PORT" \
            -U "$PROD_DB_USER" \
            -d "$PROD_DB_NAME" \
            --verbose \
            --no-owner \
            --no-privileges \
            --exclude-table-data=action_text_rich_texts \
            --exclude-table-data=active_storage_blobs \
            --exclude-table-data=active_storage_attachments \
            --exclude-table-data=logs \
            --exclude-table-data=audit_logs \
            --exclude-table-data=versions \
            > "$DUMP_FILE"
          
          # Check dump file size
          DUMP_SIZE=$(du -h "$DUMP_FILE" | cut -f1)
          echo "üì¶ Dump file created: $DUMP_SIZE"
          
          # Stop existing database container if running
          echo "üõë Stopping existing database container..."
          docker compose -f docker-compose.staging.yml down database || true
          
          # Remove existing database volume to ensure clean slate
          echo "üßπ Cleaning up existing database volume..."
          docker volume rm resilienceatlas-staging_postgres_data || true
          
          # Start fresh database container
          echo "üóÑÔ∏è Starting fresh PostgreSQL container for staging..."
          docker compose -f docker-compose.staging.yml up -d database
          
          # Wait for database to be ready
          echo "‚è≥ Waiting for staging database to be ready..."
          timeout 60s bash -c 'until docker compose -f docker-compose.staging.yml exec database pg_isready -U postgres; do sleep 2; done'
          
          # Enable PostGIS extensions
          echo "üó∫Ô∏è Enabling PostGIS extensions..."
          docker compose -f docker-compose.staging.yml exec -T database psql -U postgres -d resilienceatlas_staging -c "CREATE EXTENSION IF NOT EXISTS postgis; CREATE EXTENSION IF NOT EXISTS postgis_topology;"
          
          # Restore production data to staging database
          echo "üì• Restoring production data to staging database..."
          docker compose -f docker-compose.staging.yml exec -T database psql -U postgres -d resilienceatlas_staging < "$DUMP_FILE"
          
          # Verify staging database
          echo "‚úÖ Verifying staging database..."
          STAGING_TABLE_COUNT=$(docker compose -f docker-compose.staging.yml exec -T database psql -U postgres -d resilienceatlas_staging -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
          
          echo "üìã Staging database now contains $STAGING_TABLE_COUNT tables"
          
          # Clean up dump file
          rm "$DUMP_FILE"
          
          echo "‚úÖ Staging database setup completed successfully!"

    - name: Build and deploy application on staging server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üöÄ Starting staging deployment..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/resilienceatlas-staging' }}
          
          # Pull latest changes
          git fetch origin
          git reset --hard origin/develop
          
          echo "‚úÖ Currently on branch: $(git branch --show-current)"
          echo "‚úÖ Latest commit: $(git rev-parse --short HEAD)"
          
          # Set environment variables for deployment
          export GIT_COMMIT_SHA="${{ github.sha }}"
          export GIT_BRANCH="${{ github.ref_name }}"
          export DEPLOYMENT_ENVIRONMENT="staging"
          
          echo "üìã Environment variables:"
          echo "  GIT_COMMIT_SHA: $GIT_COMMIT_SHA"
          echo "  GIT_BRANCH: $GIT_BRANCH"
          echo "  DEPLOYMENT_ENVIRONMENT: $DEPLOYMENT_ENVIRONMENT"
          
          # Stop existing containers gracefully (except database which was handled above)
          echo "üõë Stopping existing application containers..."
          docker compose -f docker-compose.staging.yml stop frontend backend || true
          
          # Clean up any orphaned containers
          echo "üßπ Cleaning up orphaned containers..."
          docker system prune -f || true
          
          # Build fresh images
          echo "üî® Building fresh Docker images..."
          
          # Build frontend with staging environment variables
          docker build -t resilienceatlas-frontend:staging \
            --target production \
            --build-arg NEXT_PUBLIC_API_HOST=${{ secrets.STAGING_NEXT_PUBLIC_API_HOST }} \
            --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS=${{ secrets.NEXT_PUBLIC_GOOGLE_ANALYTICS }} \
            --build-arg NEXT_PUBLIC_TRANSIFEX_TOKEN=${{ secrets.NEXT_PUBLIC_TRANSIFEX_TOKEN }} \
            --build-arg NEXT_PUBLIC_TRANSIFEX_SECRET=${{ secrets.NEXT_PUBLIC_TRANSIFEX_SECRET }} \
            --build-arg NEXT_PUBLIC_GOOGLE_API_KEY=${{ secrets.NEXT_PUBLIC_GOOGLE_API_KEY }} \
            ./frontend
          
          # Build backend
          docker build -t resilienceatlas-backend:staging \
            --target production \
            ./backend
          
          echo "‚úÖ Docker images built successfully"
          
          # Start services with staging configuration
          echo "üöÄ Starting staging services..."
          docker compose -f docker-compose.staging.yml up -d --force-recreate
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          max_wait=180
          wait_time=0
          
          while [ $wait_time -lt $max_wait ]; do
            # Check if all containers are running
            running_containers=$(docker compose -f docker-compose.staging.yml ps --filter "status=running" --quiet | wc -l)
            total_containers=$(docker compose -f docker-compose.staging.yml ps --quiet | wc -l)
            
            if [ "$running_containers" -eq "$total_containers" ] && [ "$total_containers" -gt 0 ]; then
              echo "‚úÖ All containers are running ($running_containers/$total_containers)"
              break
            fi
            
            echo "‚è≥ Waiting for containers to be ready... ($running_containers/$total_containers running, $wait_time/$max_wait seconds)"
            sleep 10
            wait_time=$((wait_time + 10))
          done
          
          if [ $wait_time -ge $max_wait ]; then
            echo "‚ö†Ô∏è Some containers may not be fully ready after $max_wait seconds"
            echo "üîç Container status:"
            docker compose -f docker-compose.staging.yml ps
          fi
          
          # Database migration (if backend has migrations)
          echo "üóÑÔ∏è Running database migrations..."
          docker compose -f docker-compose.staging.yml exec -T backend bundle exec rails db:migrate || echo "‚ö†Ô∏è Migration failed or not applicable"
          
          echo "‚úÖ Services started successfully"

    - name: Run health checks
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.STAGING_HOST }}
        username: ${{ secrets.STAGING_USERNAME }}
        key: ${{ secrets.STAGING_SSH_KEY }}
        port: ${{ steps.ssh-port.outputs.port }}
        script: |
          set -e
          
          echo "üè• Performing health checks..."
          
          # Navigate to application directory
          cd ${{ secrets.STAGING_APP_PATH || '/opt/resilienceatlas-staging' }}
          
          max_attempts=30
          attempt=1
          
          # Health check for frontend
          echo "‚è≥ Checking frontend health..."
          while [ $attempt -le $max_attempts ]; do
            echo "‚è≥ Frontend health check attempt $attempt/$max_attempts..."
            
            if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
              echo "‚úÖ Frontend health check passed"
              break
            else
              echo "‚è≥ Frontend not ready yet..."
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå Frontend health check failed after $max_attempts attempts"
            echo "üîç Frontend container logs:"
            docker compose -f docker-compose.staging.yml logs --tail 50 frontend
            exit 1
          fi
          
          # Health check for backend
          echo "‚è≥ Checking backend health..."
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "‚è≥ Backend health check attempt $attempt/$max_attempts..."
            
            backend_response=$(curl -s -w "HTTP_CODE:%{http_code}" http://localhost:3001/health 2>&1 || echo "FAILED")
            
            if echo "$backend_response" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ Backend health check passed"
              echo "Response: $backend_response"
              break
            else
              echo "‚è≥ Backend not ready yet. Response: $backend_response"
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå Backend health check failed after $max_attempts attempts"
            echo "üîç Backend container logs:"
            docker compose -f docker-compose.staging.yml logs --tail 50 backend
            
            echo "üîÑ Attempting rollback..."
            docker compose -f docker-compose.staging.yml down
            # Could restore from backup images here if available
            exit 1
          fi
          
          # Final status check
          echo "üìä Final container status:"
          docker compose -f docker-compose.staging.yml ps
          
          echo "üéâ All health checks passed! Staging deployment successful!"

    - name: Cleanup security group access
      if: always()
      run: |
        # Remove the SSH access rule for the runner IP
        RUNNER_IP="${{ steps.security-group.outputs.runner-ip }}"
        if [ -n "$RUNNER_IP" ]; then
          echo "Removing SSH access for runner IP $RUNNER_IP from security group ${{ secrets.STAGING_SECURITY_GROUP_ID }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ secrets.STAGING_SECURITY_GROUP_ID }}" \
            --protocol tcp \
            --port 22 \
            --cidr "${RUNNER_IP}/32" || true
          echo "Security group rule removed successfully"
        else
          echo "No runner IP found to remove from security group"
        fi

    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ Staging deployment successful! Site: https://staging.resilienceatlas.org"
        else
          echo "‚ùå Staging deployment failed!"
          exit 1
        fi
