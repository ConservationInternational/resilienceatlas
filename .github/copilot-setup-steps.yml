name: GitHub Copilot Environment Setup
description: |
  Comprehensive setup workflow for GitHub Copilot development environment.
  This workflow prepares both local dependencies and Docker images with advanced
  caching strategies to ensure optimal development experience for the Resilience Atlas project.

  Key Features:
  - Local Node.js 22.11.0 and Ruby 3.4.4 setup for rapid iteration
  - Pre-built Docker images with layered caching for consistent environments
  - Network resilience configuration for reliable dependency downloads
  - Environment file preparation and validation
  - Comprehensive dependency caching (npm, bundle, Docker layers)
  - Performance-optimized builds with cache analytics

  Usage:
  This workflow is designed to be run by GitHub Copilot to prepare a development
  environment. It can also be adapted for use in CI/CD pipelines or local setup scripts.
  
  Prerequisites:
  - GitHub Actions runner with Docker support
  - Sufficient disk space for Docker images and caches (minimum 5GB recommended)
  - Network access to npm, RubyGems, Docker Hub, and GitHub

  Expected Runtime:
  - Initial run: 15-25 minutes (downloading and building everything)
  - Subsequent runs: 5-10 minutes (with optimal caching)
  - Cache hit ratio: 80-90% for dependency-only changes

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  NODE_VERSION: "22.11.0"
  RUBY_VERSION: "3.4.4"

steps:
  # ============================================================================
  # ENVIRONMENT PREPARATION
  # ============================================================================
  - name: Configure DNS for better connectivity
    run: |
      echo "ðŸ”§ Configuring DNS for reliable package downloads..."
      echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf.backup > /dev/null
      echo "nameserver 1.1.1.1" | sudo tee -a /etc/resolv.conf.backup > /dev/null  
      sudo cp /etc/resolv.conf.backup /etc/resolv.conf
      echo "âœ… DNS configuration updated"

  - name: Check network connectivity
    run: |
      echo "ðŸ” Verifying network connectivity to critical services..."
      
      # Test package registries
      echo "Testing npm registry:"
      curl -I https://registry.npmjs.org/ || echo "âŒ npm registry not reachable"
      
      echo "Testing RubyGems:"
      curl -I https://rubygems.org/ || echo "âŒ RubyGems not reachable"
      
      echo "Testing Docker Hub:"
      curl -I https://registry-1.docker.io/ || echo "âŒ Docker registry not reachable"
      
      echo "Testing GitHub:"
      curl -I https://github.com/ || echo "âŒ GitHub not reachable"
      
      echo "Testing Cypress CDN:"
      curl -I https://download.cypress.io/ || echo "âŒ Cypress downloads not reachable"
      
      echo "âœ… Network connectivity check completed"

  # ============================================================================
  # LOCAL DEVELOPMENT DEPENDENCIES
  # ============================================================================
  - name: Set up Node.js environment
    uses: actions/setup-node@v4
    with:
      node-version: ${{ env.NODE_VERSION }}
      cache: 'npm'
      cache-dependency-path: |
        frontend/package-lock.json
        frontend/package.json

  - name: Set up Ruby environment
    uses: ruby/setup-ruby@v1
    with:
      ruby-version: ${{ env.RUBY_VERSION }}
      bundler-cache: true
      working-directory: backend
      cache-version: 1

  - name: Verify local tool versions
    run: |
      echo "ðŸ” Verifying local development tools..."
      echo "Node.js version: $(node --version)"
      echo "npm version: $(npm --version)"
      echo "Ruby version: $(ruby --version)"
      echo "Bundler version: $(bundle --version)"
      echo "Docker version: $(docker --version)"
      echo "Docker Compose version: $(docker compose version)"

  # ============================================================================
  # ENVIRONMENT FILE PREPARATION
  # ============================================================================
  - name: Prepare environment files
    run: |
      echo "ðŸ“ Setting up environment files..."
      
      # Copy environment templates
      cp .env.example .env
      cp frontend/.env.example frontend/.env  
      
      # Handle backend environment file - check for .env.sample or create minimal .env
      if [ -f "backend/.env.sample" ]; then
        cp backend/.env.sample backend/.env
        echo "âœ… Backend .env created from .env.sample"
      elif [ -f "backend/.env.example" ]; then
        cp backend/.env.example backend/.env
        echo "âœ… Backend .env created from .env.example"
      else
        echo "âš ï¸ No backend environment template found, creating minimal .env"
        echo "# Backend Development Environment" > backend/.env
        echo "RAILS_ENV=development" >> backend/.env
        echo "DATABASE_URL=postgres://postgres:postgres@localhost:5432/resilienceatlas_development" >> backend/.env
        echo "DATABASE_HOST=localhost" >> backend/.env
        echo "DATABASE_PORT=5432" >> backend/.env
        echo "DATABASE_NAME=resilienceatlas_development" >> backend/.env
        echo "DATABASE_USER=postgres" >> backend/.env
        echo "DATABASE_PASSWORD=postgres" >> backend/.env
        echo "SECRET_KEY_BASE=development_secret_key_base_that_is_long_enough_for_rails_to_accept_it_properly" >> backend/.env
        echo "DEVISE_KEY=development_devise_key_that_is_also_long_enough_for_the_application_to_work" >> backend/.env
        echo "REDIS_URL=redis://localhost:6379/0" >> backend/.env
        echo "BACKEND_URL=http://localhost:3001" >> backend/.env
        echo "FRONTEND_URL=http://localhost:3000" >> backend/.env
        echo "CORS_ORIGINS=http://localhost:3000" >> backend/.env
        echo "RAILS_FORCE_SSL=false" >> backend/.env
        echo "âœ… Minimal backend .env created"
      fi
      
      echo "âœ… Environment files setup completed"
      
      # Validate environment file syntax
      echo "ðŸ” Validating environment files..."
      if [ -f ".env" ]; then
        echo "âœ… Root .env file exists"
      else
        echo "âŒ Root .env file missing"
        exit 1
      fi
      
      if [ -f "frontend/.env" ]; then
        echo "âœ… Frontend .env file exists"
      else
        echo "âŒ Frontend .env file missing"
        exit 1
      fi
      
      if [ -f "backend/.env" ]; then
        echo "âœ… Backend .env file exists"
      else
        echo "âŒ Backend .env file missing"
        exit 1
      fi

  # ============================================================================
  # LOCAL DEPENDENCY INSTALLATION
  # ============================================================================
  - name: Install frontend dependencies locally
    working-directory: frontend
    run: |
      echo "ðŸ“¦ Installing frontend dependencies locally..."
      echo "This provides fast local development capabilities"
      
      # Configure npm for better network resilience
      npm config set registry https://registry.npmjs.org/
      npm config set fetch-timeout 600000
      npm config set fetch-retry-mintimeout 10000
      npm config set fetch-retry-maxtimeout 60000
      npm config set fetch-retries 5
      
      # Install with legacy peer deps flag for compatibility
      npm install --legacy-peer-deps --no-audit --no-fund
      
      echo "âœ… Frontend dependencies installed locally"
      echo "Local development ready for: npm run dev, npm run build, npm run lint"

  - name: Install backend dependencies locally
    working-directory: backend
    run: |
      echo "ðŸ“¦ Installing backend dependencies locally..."
      echo "This enables local Rails commands and faster iteration"
      
      # Install gems
      bundle install --jobs 4 --retry 3
      
      echo "âœ… Backend dependencies installed locally"
      echo "Local development ready for: bundle exec rails, bundle exec rspec"

  # ============================================================================
  # DOCKER BUILDX SETUP
  # ============================================================================
  - name: Set up Docker Buildx with advanced caching
    uses: docker/setup-buildx-action@v3
    with:
      driver-opts: image=moby/buildkit:buildx-stable-1
      buildkitd-flags: --allow-insecure-entitlement security.insecure

  - name: Generate cache keys for optimal layer reuse
    id: cache-keys
    run: |
      echo "ðŸ”‘ Generating content-based cache keys..."
      
      # Generate cache keys based on file content for maximum cache efficiency
      echo "backend-dockerfile-hash=$(sha256sum backend/Dockerfile | cut -d' ' -f1)" >> $GITHUB_OUTPUT
      echo "frontend-dockerfile-hash=$(sha256sum frontend/Dockerfile | cut -d' ' -f1)" >> $GITHUB_OUTPUT
      echo "gemfile-hash=$(sha256sum backend/Gemfile backend/Gemfile.lock | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT
      echo "package-hash=$(sha256sum frontend/package.json frontend/package-lock.json | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT
      echo "ruby-version=${{ env.RUBY_VERSION }}" >> $GITHUB_OUTPUT
      echo "node-version=${{ env.NODE_VERSION }}" >> $GITHUB_OUTPUT
      echo "date=$(date +%Y%m%d)" >> $GITHUB_OUTPUT
      
      echo "âœ… Cache keys generated for optimal reuse"

  # ============================================================================
  # DOCKER CACHE MANAGEMENT
  # ============================================================================
  - name: Restore Docker buildx cache
    uses: actions/cache@v4
    with:
      path: /tmp/.buildx-cache
      key: ${{ runner.os }}-copilot-buildx-${{ steps.cache-keys.outputs.backend-dockerfile-hash }}-${{ steps.cache-keys.outputs.frontend-dockerfile-hash }}-${{ steps.cache-keys.outputs.gemfile-hash }}-${{ steps.cache-keys.outputs.package-hash }}
      restore-keys: |
        ${{ runner.os }}-copilot-buildx-${{ steps.cache-keys.outputs.backend-dockerfile-hash }}-${{ steps.cache-keys.outputs.frontend-dockerfile-hash }}-
        ${{ runner.os }}-copilot-buildx-
        ${{ runner.os }}-integration-buildx-
        ${{ runner.os }}-backend-buildx-${{ steps.cache-keys.outputs.backend-dockerfile-hash }}-
        ${{ runner.os }}-frontend-buildx-${{ steps.cache-keys.outputs.frontend-dockerfile-hash }}-
        ${{ runner.os }}-buildx-

  - name: Warm Docker cache with base images
    run: |
      echo "ðŸ”¥ Pre-pulling base images to warm cache..."
      
      # Pull base images in parallel for faster setup
      {
        echo "Pulling Ruby base image..."
        docker pull ruby:${{ env.RUBY_VERSION }}-bullseye || echo "Could not pre-pull Ruby image"
      } &
      
      {
        echo "Pulling Node.js base image..."
        docker pull node:${{ env.NODE_VERSION }}-bullseye || echo "Could not pre-pull Node image"
      } &
      
      {
        echo "Pulling PostGIS image..."
        docker pull postgis/postgis:15-3.3 || echo "Could not pre-pull PostGIS image"
      } &
      
      {
        echo "Pulling Redis image..."
        docker pull redis:7-alpine || echo "Could not pre-pull Redis image"
      } &
      
      {
        echo "Pulling Cypress image..."
        docker pull cypress/included:13.15.0 || echo "Could not pre-pull Cypress image"
      } &
      
      wait
      echo "âœ… Base images warmed"

  # ============================================================================
  # DOCKER IMAGE BUILDING
  # ============================================================================
  - name: Build backend Docker image with enhanced caching
    run: |
      echo "ðŸ—ï¸ Building backend Docker image with optimized caching..."
      
      # Build with comprehensive caching strategy
      docker buildx build \
        --cache-from=type=local,src=/tmp/.buildx-cache \
        --cache-from=type=gha \
        --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
        --cache-to=type=gha,mode=max \
        --target test \
        --tag resilienceatlas-backend:copilot \
        --load \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg RUBY_VERSION=${{ env.RUBY_VERSION }} \
        ./backend
      
      echo "âœ… Backend Docker image built and cached"

  - name: Build frontend Docker image with enhanced caching
    run: |
      echo "ðŸ—ï¸ Building frontend Docker image with optimized caching..."
      
      # Build with test environment configuration
      docker buildx build \
        --cache-from=type=local,src=/tmp/.buildx-cache \
        --cache-from=type=gha \
        --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
        --cache-to=type=gha,mode=max \
        --target test \
        --tag resilienceatlas-frontend:copilot \
        --load \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --build-arg NODE_VERSION=${{ env.NODE_VERSION }} \
        --build-arg NEXT_PUBLIC_API_HOST=http://localhost:3001 \
        --build-arg NEXT_PUBLIC_GOOGLE_ANALYTICS=GA_COPILOT_ID \
        --build-arg NEXT_PUBLIC_TRANSIFEX_TOKEN=copilot_token \
        --build-arg NEXT_PUBLIC_TRANSIFEX_SECRET=copilot_secret \
        --build-arg NEXT_PUBLIC_GOOGLE_API_KEY=copilot_api_key \
        --build-arg CYPRESS_INSTALL_BINARY=0 \
        ./frontend
      
      echo "âœ… Frontend Docker image built and cached"

  - name: Build coordinated multi-service images (docker bake)
    run: |
      echo "ðŸ—ï¸ Building coordinated multi-service images using docker bake..."
      
      # Use docker bake for coordinated builds if available
      if docker buildx bake \
        --file .github/docker-bake.hcl \
        --set="*.cache-from=type=local,src=/tmp/.buildx-cache" \
        --set="*.cache-from=type=gha" \
        --set="*.cache-to=type=local,dest=/tmp/.buildx-cache-coordinated,mode=max" \
        --set="*.cache-to=type=gha,mode=max" \
        --load \
        default 2>/dev/null; then
        echo "âœ… Coordinated build successful - maximum cache efficiency achieved"
        
        # Merge coordinated cache with existing cache
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-coordinated /tmp/.buildx-cache
      else
        echo "âš ï¸ Coordinated build not available, using individual builds"
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      fi

  # ============================================================================
  # DEVELOPMENT ENVIRONMENT VALIDATION
  # ============================================================================
  - name: Start development database
    run: |
      echo "ðŸ—„ï¸ Starting development database..."
      
      # Start PostgreSQL + PostGIS for development
      docker compose -f docker-compose.dev.yml up -d db
      
      # Wait for database to be ready
      echo "Waiting for database to be ready..."
      timeout 60s bash -c 'until docker compose -f docker-compose.dev.yml exec -T db pg_isready -U postgres; do sleep 2; done'
      
      echo "âœ… Development database ready"

  - name: Validate local frontend development
    working-directory: frontend
    run: |
      echo "ðŸ” Validating local frontend development capabilities..."
      
      # Test TypeScript compilation
      echo "Testing TypeScript compilation..."
      npm run check-types
      
      # Test linting
      echo "Testing ESLint..."
      npm run lint --max-warnings=0 || echo "ESLint warnings found (acceptable for setup)"
      
      # Test Prettier
      echo "Testing Prettier formatting..."
      npm run prettier --check || echo "Prettier formatting issues found (can be auto-fixed)"
      
      # Test build process
      echo "Testing production build..."
      npm run build
      
      echo "âœ… Local frontend development validated"

  - name: Validate local backend development
    working-directory: backend
    run: |
      echo "ðŸ” Validating local backend development capabilities..."
      
      # Test Rails environment
      echo "Testing Rails environment..."
      bundle exec rails runner 'puts "Rails #{Rails.version}, Ruby #{RUBY_VERSION}"'
      
      # Test database connection (requires database to be running)
      echo "Testing database connection..."
      bundle exec rails runner 'ActiveRecord::Base.connection.execute("SELECT 1")' 2>/dev/null || echo "Database not available for connection test"
      
      # Test linting
      echo "Testing StandardRB linting..."
      bundle exec standardrb --format simple || echo "StandardRB issues found (can be auto-fixed with --fix)"
      
      # Test security analysis
      echo "Testing Brakeman security analysis..."
      bundle exec brakeman --quiet --no-exit-on-warn || echo "Security warnings found (review needed)"
      
      echo "âœ… Local backend development validated"

  - name: Validate Docker development environment
    run: |
      echo "ðŸ” Validating Docker development environment..."
      
      # Test Docker image functionality
      echo "Testing backend Docker image..."
      docker run --rm resilienceatlas-backend:copilot bundle exec ruby -e 'puts "Backend Docker image functional"'
      
      echo "Testing frontend Docker image..."
      docker run --rm resilienceatlas-frontend:copilot node --version
      
      # Test docker-compose configuration
      echo "Testing docker-compose configuration..."
      docker compose -f docker-compose.dev.yml config --quiet
      docker compose -f docker-compose.test.yml config --quiet
      
      echo "âœ… Docker development environment validated"

  # ============================================================================
  # CACHE ANALYTICS AND REPORTING
  # ============================================================================
  - name: Report cache analytics and setup summary
    run: |
      echo "ðŸ“Š Cache Analytics and Setup Summary"
      echo "=================================="
      
      # Cache size analysis
      echo "Docker buildx cache size:"
      du -sh /tmp/.buildx-cache 2>/dev/null || echo "No cache found"
      
      echo ""
      echo "Docker system usage:"
      docker system df
      
      echo ""
      echo "Image sizes:"
      docker images | grep resilienceatlas | head -10
      
      echo ""
      echo "âœ… Environment Setup Complete!"
      echo "=============================="
      echo ""
      echo "ðŸš€ Your Resilience Atlas development environment is ready!"
      echo ""
      echo "Local Development:"
      echo "  â€¢ Node.js ${{ env.NODE_VERSION }} installed with frontend dependencies"
      echo "  â€¢ Ruby ${{ env.RUBY_VERSION }} installed with backend dependencies"
      echo "  â€¢ Environment files configured"
      echo "  â€¢ Development database running"
      echo ""
      echo "Docker Environment:"
      echo "  â€¢ Pre-built backend image: resilienceatlas-backend:copilot"
      echo "  â€¢ Pre-built frontend image: resilienceatlas-frontend:copilot"
      echo "  â€¢ Optimized cache layers for fast rebuilds"
      echo "  â€¢ Test infrastructure ready"
      echo ""
      echo "Next Steps:"
      echo "  â€¢ Start development: docker compose -f docker-compose.dev.yml up -d"
      echo "  â€¢ Local frontend: cd frontend && npm run dev"
      echo "  â€¢ Local backend: cd backend && bundle exec rails server"
      echo "  â€¢ Run tests: ./bin/test (in respective directories)"
      echo ""
      echo "For detailed development instructions, see:"
      echo "  â€¢ .github/copilot-instructions.md"
      echo "  â€¢ README.md"

  # ============================================================================
  # CLEANUP AND OPTIMIZATION
  # ============================================================================
  - name: Cleanup and optimize for future runs
    if: always()
    run: |
      echo "ðŸ§¹ Cleaning up temporary files and optimizing for future runs..."
      
      # Remove temporary build files but keep cache
      docker system prune -f --filter "until=1h"
      
      # Remove old cache directories that aren't needed
      find /tmp -name ".buildx-cache*" -type d -mtime +1 -exec rm -rf {} + 2>/dev/null || true
      
      echo "âœ… Cleanup completed"